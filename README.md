# polyscript ü¶Ä

> Polyglot script runner ‚Äî Rust CLI that dispatches to **16 languages** via FFI and subprocess bridges

187 lines of `src` across 5 files. 13 language bridges generated by two macros.

---

## Table of contents

- [Why polyscript?](#why-polyscript)
- [Language quick-reference](#language-quick-reference)
- [Install](#install)
- [Quick start](#quick-start)
- [Usage scenarios](#usage-scenarios)
- [Subcommand reference](#subcommand-reference)
- [Bridge architecture](#bridge-architecture)
- [Data IPC ‚Äî passing data between languages](#data-ipc--passing-data-between-languages)
- [Project structure](#project-structure)
- [Error handling](#error-handling)
- [Building and testing](#building-and-testing)
- [Known limitations](#known-limitations)
- [Roadmap](#roadmap)
- [License](#license)

---

## Why polyscript?

### The problem

Every language excels at a different task, but calling them from a unified pipeline requires writing boilerplate launchers, remembering each runtime's flag syntax, and managing inconsistent error-propagation conventions:

```bash
# without polyscript ‚Äî each invocation is bespoke
python3 preprocess.py /data/input.parquet
julia --threads auto simulate.jl /tmp/features.arrow
go run serve.go --port 8080
Rscript plot.r /tmp/result.arrow
node transform.js /tmp/report.json
```

At the Rust level, bridging even two languages means separate crates, separate process-spawning boilerplate, and separate exit-code handling per language.

### The solution

```bash
# with polyscript ‚Äî one binary, one interface, consistent error propagation
polyscript py    preprocess.py   /data/input.parquet
polyscript jl    simulate.jl     /tmp/features.arrow
polyscript go    serve.go        --port 8080
polyscript r     plot.r          /tmp/result.arrow
polyscript js    transform.js    /tmp/report.json
```

```rust
// src/bridge/mod.rs ‚Äî 13 language bridges declared in 15 lines
sp_bridge!(julia, "julia");
sp_bridge!(go,    "go",    "run");
sp_bridge!(js,    "node");
sp_bridge!(ts,    "deno",  "run");
sp_bridge!(lua,   "lua");
sp_bridge!(r,     "Rscript");
sp_bridge!(mojo,  "mojo");
sp_bridge!(zig,   "zig",   "run");
sp_bridge!(wasm,  "wasmtime", "run");
sp_bridge!(hs,    "runghc");
sp_bridge!(swift, "swift");
sp_bridge!(kt,    "kotlinc", "-script");
sp_bridge!(nim,   "nim",  "r");
cr_bridge!(fort,  "gfortran");         // compile ‚Üí run
```

### Who is it for?

| Audience | Pain point polyscript solves |
|---|---|
| **ML pipeline engineers** | Chain Python preprocessing ‚Üí Julia simulation ‚Üí R visualisation with one orchestrator, consistent exit-code propagation, and a clear data-passing contract (file path ‚Üí Arrow IPC) |
| **Polyglot tooling authors** | Invoke any language runtime without maintaining per-language launcher scripts or remembering each runtime's argument conventions |
| **Systems + scripting hybrid projects** | Keep Rust as the safe, fast entry-point while delegating domain logic to the language with the best library (Fortran for HPC, Haskell for DSL, Lua for embedded scripting) |
| **Researchers prototyping pipelines** | Rapidly wire together scripts in different languages without committing to a full FFI rewrite ‚Äî upgrade to in-process bridges (PyO3, libjulia) later |

### What polyscript is NOT

- **Not a process supervisor or task queue** ‚Äî no retry, scheduling, or daemon management. Use `systemd`, `supervisord`, or a workflow engine for that.
- **Not a data transformation layer** ‚Äî polyscript passes file paths or string args; actual data processing lives entirely inside the called script.
- **Not a language interop framework** ‚Äî there is no shared type system across language boundaries. Data contracts are the caller's responsibility.
- **Not a replacement for native FFI** ‚Äî Python (PyO3) and C++ (libloading) run in-process for zero startup cost; all other languages pay subprocess overhead on every call. For hot loops, migrate to in-process bridges.

---

## Language quick-reference

### Choosing the right language

| Task | Best language | Subcommand | Reason |
|---|---|---|---|
| ML training / inference | Python | `py` | PyTorch / scikit-learn ecosystem |
| Heavy numerical simulation | Julia | `jl` | JIT to C speed, SciML, ODE solvers |
| C++ library reuse / SIMD | C++ | `cpp` | In-process via libloading, zero overhead |
| Cloud API / concurrent CLI | Go | `go` | Goroutines, static binary, 50 ms startup |
| Web scraping / JSON transform | JavaScript | `js` | npm ecosystem, event loop, 40 ms startup |
| Type-safe scripting / serverless | TypeScript | `ts` | Deno sandbox, native TS, 60 ms startup |
| Game logic / embedded config | Lua | `lua` | 200 KB runtime, C-embeddable, LuaJIT |
| Statistical analysis / publication plots | R | `r` | ggplot2, CRAN, research-first design |
| Python code at C++ speed | Mojo | `mojo` | Python superset, MLIR backend, GPU-ready |
| C replacement / cross-compile | Zig | `zig` | `comptime`, C ABI, built-in cross-compilation |
| Secure sandboxed plugins | WebAssembly | `wasm` | wasmtime WASI, language-agnostic input |
| Finance / DSL / proof-strength code | Haskell | `hs` | Pure FP, type-level correctness, monadic IO |
| Apple SDK / macOS-native | Swift | `swift` | ARC, Obj-C interop, Embedded Swift |
| JVM ecosystem / Android | Kotlin | `kt` | Null-safe, coroutines, Java 100% interop |
| Python syntax + C speed (niche) | Nim | `nim` | Compiles to C, macros, GC/RC/manual |
| HPC / CFD / climate models | Fortran | `fort` | Array-first, MPI/OpenMP, compiler auto-vectorisation |

### Language startup cost

| Language | Bridge | Startup overhead | Notes |
|---|---|---|---|
| Python | PyO3 in-process | **zero** | Interpreter stays alive inside Rust process |
| C++ | libloading | **zero** | `.dylib`/`.so` loaded once, function pointer called |
| Go | subprocess | ~30 ms | Statically compiled binary ‚Äî fastest subprocess |
| JavaScript | subprocess | ~40 ms | Node.js V8 cold start |
| TypeScript | subprocess | ~60 ms | Deno V8 + permission check |
| Lua | subprocess | ~10 ms | Minimal VM boot |
| R | subprocess | ~300 ms | Full R environment initialisation |
| Mojo | subprocess | ~200 ms | MLIR JIT setup |
| Zig | subprocess | ~50 ms | `zig run` compile-then-execute |
| WebAssembly | subprocess | ~80 ms | wasmtime module instantiation |
| Haskell | subprocess | ~150 ms | GHC runtime system init |
| Swift | subprocess | ~200 ms | Swift stdlib + Foundation load |
| Kotlin | subprocess | ~500 ms‚Äì1 s | JVM boot (mitigation: GraalVM Native Image) |
| Nim | subprocess | ~100 ms | `nim r` compile-then-execute |
| Fortran | compile + run | **compile time** + ~5 ms | gfortran compiles to `/tmp/polyscript_out` |
| Julia | subprocess | **1‚Äì4 s** | JIT compilation (mitigation: `libjulia-sys` FFI) |

### Python ‚Üí polyscript migration pattern

```python
# before: raw subprocess calls scattered through your codebase
import subprocess
result = subprocess.run(["julia", "simulate.jl", "features.arrow"], check=True)
result = subprocess.run(["Rscript", "plot.r", "result.arrow"], check=True)
```

```bash
# after: polyscript as the single orchestration layer
polyscript jl simulate.jl   features.arrow
polyscript r  plot.r        result.arrow
```

### C++ shared library convention

Any C++ function callable via `polyscript cpp` must export:

```cpp
// extern "C" suppresses name mangling ‚Äî required for libloading symbol lookup
extern "C" int run(int argc, const char** argv) {
    // argc: number of extra args passed after `polyscript cpp <lib> <func>`
    // argv: the extra args as C strings
    // return 0 on success, non-zero to propagate an error to Rust
    return 0;
}
```

```bash
# Compile
g++ -shared -fPIC -o libexample.dylib scripts/cpp/example.cpp   # macOS
g++ -shared -fPIC -o libexample.so    scripts/cpp/example.cpp   # Linux

# Run
polyscript cpp ./libexample.dylib run arg1 arg2
```

### Fortran compile convention

`fort` compiles the source to a temporary binary at `/tmp/polyscript_out` via `gfortran`, then executes it. The binary is overwritten on each call ‚Äî not safe for concurrent `fort` subcommands.

```fortran
! scripts/fortran/example.f90
program example
  integer :: i, argc
  character(len=256) :: arg
  argc = command_argument_count()
  do i = 1, argc
    call get_command_argument(i, arg)
    write(*,*) trim(arg)
  end do
end program example
```

```bash
polyscript fort scripts/fortran/example.f90  hello world
```

---

## Install

### From source

```bash
git clone https://github.com/fumishiki/polyscript
cd polyscript
cargo build --release
# binary: ./target/release/polyscript
```

### Add to PATH

```bash
cp target/release/polyscript ~/.local/bin/
# or
cargo install --path .
```

### Runtime prerequisites

polyscript itself requires only Rust + Python development headers (for PyO3).  
Each `sp_bridge` subcommand requires the corresponding runtime in `$PATH`.  
A missing runtime triggers an immediate, explicit OS error ‚Äî no silent fallback.

| Language | Minimum version | Install |
|---|---|---|
| Python | 3.8+ | system package / pyenv |
| Julia | 1.9+ | [julialang.org](https://julialang.org/downloads/) |
| Go | 1.21+ | [go.dev](https://go.dev/dl/) |
| Node.js | 18+ | [nodejs.org](https://nodejs.org/) |
| Deno | 1.40+ | `curl -fsSL https://deno.land/install.sh \| sh` |
| Lua | 5.4+ | `brew install lua` / `apt install lua5.4` |
| R | 4.0+ | [cran.r-project.org](https://cran.r-project.org/) |
| Mojo | 24.4+ | [docs.modular.com](https://docs.modular.com/mojo/manual/get-started) |
| Zig | 0.12+ | [ziglang.org](https://ziglang.org/download/) |
| wasmtime | 20+ | `curl https://wasmtime.dev/install.sh -sSf \| bash` |
| GHC | 9.4+ | `ghcup install ghc` |
| Swift | 5.9+ | [swift.org/install](https://swift.org/install/) |
| Kotlin | 1.9+ | `brew install kotlin` / [SDKMAN](https://sdkman.io/) |
| Nim | 2.0+ | [nim-lang.org/install](https://nim-lang.org/install.html) |
| GFortran | 12+ | `brew install gcc` / `apt install gfortran` |

> **Reproducible environments** ‚Äî `devbox.json` and `Dockerfile` are planned (see [Roadmap](#roadmap)).  
> Until then, [Devbox](https://www.jetify.com/devbox/) or [mise](https://mise.jdx.dev/) are recommended for pinning runtime versions.

---

## Quick start

```bash
# Python ‚Äî in-process PyO3, zero subprocess overhead
polyscript py scripts/python/example.py hello world
# ‚Üí [Python] args: ['hello', 'world']

# Julia ‚Äî subprocess
polyscript jl scripts/julia/example.jl hello world
# ‚Üí [Julia] args: hello world (as ARGS)

# Go ‚Äî subprocess via `go run`
polyscript go scripts/go/example.go hello world
# ‚Üí [Go] args: [hello world]

# TypeScript (Deno) ‚Äî subprocess with native TS support
polyscript ts scripts/ts/example.ts hello world
# ‚Üí [TypeScript/Deno] args: [ "hello", "world" ]

# WebAssembly ‚Äî compile .wat first, then run
wat2wasm scripts/wasm/example.wat -o /tmp/example.wasm
polyscript wasm /tmp/example.wasm
# ‚Üí [Wasm] hello

# C++ shared library ‚Äî compile, then invoke named export
g++ -shared -fPIC -o /tmp/libex.dylib scripts/cpp/example.cpp
polyscript cpp /tmp/libex.dylib run arg1
# ‚Üí [C++] argc: 1  argv[0]: arg1

# Fortran ‚Äî compile + run in one step
polyscript fort scripts/fortran/example.f90 hello world
# ‚Üí hello
# ‚Üí world
```

---

## Usage scenarios

### ML data pipeline

```bash
# 1. Python: preprocess raw data ‚Üí Arrow IPC
polyscript py  pipeline/preprocess.py  /data/raw.parquet  /tmp/features.arrow

# 2. Julia: heavy ODE simulation over features
polyscript jl  pipeline/simulate.jl    /tmp/features.arrow  /tmp/result.arrow

# 3. R: publication-quality visualisation
polyscript r   pipeline/plot.r         /tmp/result.arrow    /tmp/figures/

# 4. Python: aggregate and export final report
polyscript py  pipeline/aggregate.py   /tmp/result.arrow    /tmp/report.json
```

Each script reads its input path from `argv[1]` and writes output to `argv[2]`.  
The Rust CLI enforces exit-code propagation ‚Äî any non-zero exit stops the pipeline.

### Polyglot web service backend

```bash
# Go handles the HTTP routing (goroutines, low memory)
polyscript go  server/router.go  --port 8080 &

# Node.js processes webhook payloads (npm ecosystem for JSON/NDJSON)
polyscript js  workers/webhook.js  --queue redis://localhost

# Haskell validates financial transaction rules (type-level correctness)
polyscript hs  rules/validate.hs  /tmp/txn.json
```

### Secure plugin execution

```bash
# Compile untrusted plugin to WebAssembly
zig build-exe -target wasm32-wasi plugin.zig -femit-bin=plugin.wasm

# Run in wasmtime sandbox ‚Äî plugin cannot access host filesystem
polyscript wasm plugin.wasm  --input /tmp/data.json
```

### Scientific computing pipeline (Fortran + Python)

```bash
# Fortran: solve large sparse linear system (existing HPC code)
polyscript fort legacy/fem_solver.f90  /tmp/stiffness.dat  /tmp/displacement.dat

# Python: post-process and visualise displacement field
polyscript py  postprocess.py  /tmp/displacement.dat
```

---

## Subcommand reference

```
polyscript <COMMAND> <script|lib> [args...]
```

### Shared argument type

All script-based subcommands (`py`, `jl`, `go`, ‚Ä¶, `fort`) accept the same two arguments:

| Position | Type | Description |
|---|---|---|
| 1 | `String` | Path to the script file (or `.wasm` module) |
| 2‚Ä¶ | `Vec<String>` | Zero or more arguments forwarded verbatim to the script |

### `cpp` ‚Äî special signature

```
polyscript cpp <lib> <func> [args...]
```

| Argument | Description |
|---|---|
| `<lib>` | Path to compiled `.dylib` / `.so` |
| `<func>` | Symbol name to look up via `libloading` |
| `[args...]` | Forwarded as `argv` to the exported C function |

### Full subcommand table

| Subcommand | Runtime command | Script convention |
|---|---|---|
| `py` | PyO3 in-process | Any `.py` file. `sys.argv[0]` = script path |
| `jl` | `julia <script> [args]` | `ARGS` receives the extra args |
| `go` | `go run <script> [args]` | Single-file package (`package main`) |
| `js` | `node <script> [args]` | `process.argv.slice(2)` for args |
| `ts` | `deno run <script> [args]` | `Deno.args` for args |
| `lua` | `lua <script> [args]` | `arg[1]`, `arg[2]`, ‚Ä¶ |
| `r` | `Rscript <script> [args]` | `commandArgs(trailingOnly=TRUE)` |
| `mojo` | `mojo <script> [args]` | `argv()[1:]` |
| `zig` | `zig run <script> [args]` | `std.process.args()` |
| `wasm` | `wasmtime run <wasm> [args]` | WASI `argv` via `wasi:cli/environment` |
| `hs` | `runghc <script> [args]` | `System.Environment.getArgs` |
| `swift` | `swift <script> [args]` | `CommandLine.arguments.dropFirst()` |
| `kt` | `kotlinc -script <script> [args]` | `args` array in script scope |
| `nim` | `nim r <script> [args]` | `commandLineParams()` |
| `fort` | `gfortran <src> -o /tmp/polyscript_out && /tmp/polyscript_out [args]` | `get_command_argument(i, arg)` |
| `cpp` | libloading symbol lookup | `extern "C" int run(int argc, const char** argv)` |

---

## Bridge architecture

### Overview

```
polyscript binary
‚îÇ
‚îú‚îÄ‚îÄ bridge::python   PyO3 (in-process)           src/bridge/python.rs  (20 lines)
‚îú‚îÄ‚îÄ bridge::cpp      libloading (dynamic load)   src/bridge/cpp.rs     (23 lines)
‚îÇ
‚îî‚îÄ‚îÄ bridge::mod      sp() / cr() + macros        src/bridge/mod.rs     (63 lines)
     ‚îÇ
     ‚îú‚îÄ sp(cmd, pre[], script, args[])
     ‚îÇ    ‚îî‚îÄ std::process::Command::new(cmd).args(pre).arg(script).args(args).status()
     ‚îÇ
     ‚îú‚îÄ cr(compiler, flags[], script, args[])
     ‚îÇ    ‚îú‚îÄ compile: Command::new(compiler).args(flags).arg(script).arg("-o").arg(tmp)
     ‚îÇ    ‚îî‚îÄ run:     Command::new(tmp).args(args)
     ‚îÇ
     ‚îú‚îÄ macro sp_bridge!($mod, $cmd $(, $pre)*)
     ‚îÇ    ‚îî‚îÄ generates: pub mod $mod { pub fn run(s,a) { super::sp($cmd, &[$pre..], s, a) } }
     ‚îÇ
     ‚îî‚îÄ macro cr_bridge!($mod, $compiler $(, $flag)*)
          ‚îî‚îÄ generates: pub mod $mod { pub fn run(s,a) { super::cr($compiler, &[$flag..], s, a) } }
```

### Why two macros are sufficient

`sp_bridge!` covers every language whose runtime **interprets or JIT-compiles at call time** with a single command invocation:

```
cmd [pre...] script [args...]
 ‚îÇ      ‚îÇ       ‚îÇ       ‚îÇ
 ‚îÇ      ‚îÇ       ‚îÇ    forwarded verbatim to the script's argv
 ‚îÇ      ‚îÇ    polyscript's first positional argument
 ‚îÇ   optional fixed flags (e.g. "run", "-script")
runtime binary name
```

`cr_bridge!` covers **AOT-compiled languages** where the source must be compiled to a binary first:

```
Step 1: compiler [flags...] source -o /tmp/polyscript_out
Step 2: /tmp/polyscript_out [args...]
```

Currently only Fortran (`gfortran`) uses `cr_bridge!`. Zig uses `sp_bridge!` because `zig run` handles compile+execute internally.

### Python bridge ‚Äî PyO3 detail (`src/bridge/python.rs`)

Python is the only language that runs **inside the Rust process**. The PyO3 bridge:

1. Acquires the GIL via `Python::with_gil`
2. Imports `sys` and sets `sys.argv = [script, ...args]`
3. Reads the script file from disk
4. Executes it with `py.run_bound(&code, None, None)`

```rust
pub fn run(script: &str, args: &[String]) -> Result<()> {
    let code = fs::read_to_string(script)?;
    Python::with_gil(|py| {
        let sys = py.import_bound("sys")?;
        let argv: Vec<&str> = std::iter::once(script)
            .chain(args.iter().map(|s| s.as_str()))
            .collect();
        sys.setattr("argv", PyList::new_bound(py, &argv))?;
        py.run_bound(&code, None, None)?;
        Ok(())
    })
}
```

Implications: the Python interpreter is initialised once per `polyscript py` invocation. All Python stdlib and installed packages are accessible. `import` statements inside the script resolve against the host's `sys.path`.

### C++ bridge ‚Äî libloading detail (`src/bridge/cpp.rs`)

The C++ bridge uses `libloading` to open a shared library at runtime and call a named symbol by byte-string lookup:

```rust
unsafe {
    let lib  = Library::new(lib_path)?;
    let func: Symbol<unsafe extern "C" fn(i32, *const *const i8) -> i32>
            = lib.get(func_name.as_bytes())?;
    let ret  = func(c_ptrs.len() as i32, c_ptrs.as_ptr());
    ensure!(ret == 0, "C++ function returned {ret}");
}
```

The `unsafe` block is necessary for raw FFI. Safety invariants required by callers:
- The symbol must conform to `extern "C" int <name>(int argc, const char** argv)`
- The library must not be unloaded while the function executes
- Exception must not cross the FFI boundary (`noexcept` recommended on the C++ side)

### `main.rs` ‚Äî dispatch (`src/main.rs`)

The shared `S` struct eliminates repeated `script: String, args: Vec<String>` declarations across 15 subcommand variants:

```rust
#[derive(Args)]
struct S { script: String, args: Vec<String> }

#[derive(Subcommand)]
enum Cmd {
    Py(S), Jl(S), Go(S), Js(S), Ts(S), Lua(S), R(S),
    Mojo(S), Zig(S), Wasm(S), Hs(S), Swift(S), Kt(S), Nim(S), Fort(S),
    Cpp { lib: String, func: String, args: Vec<String> },
}
```

The dispatch is a single `match` with no indirection:

```rust
match Cli::parse().cmd {
    Py(a)    => python::run(&a.script, &a.args),
    Jl(a)    => julia::run(&a.script, &a.args),
    Go(a)    => go::run(&a.script, &a.args),
    // ... 12 more single-line arms
    Cpp { lib, func, args } => cpp::run(&lib, &func, &args),
}
```

---

## Data IPC ‚Äî passing data between languages

The subcommand signature `<script> [args...]` passes **string arguments only**.  
For structured data, use the following layered strategy:

### Strategy by data size

| Data size | Method | Receive in script |
|---|---|---|
| Small ‚Äî flags, IDs, counts | CLI `[args...]` | `sys.argv`, `ARGS`, `os.Args`, etc. |
| Medium ‚Äî MB to hundreds of MB | **Parquet / Arrow IPC file path** as `args[1]` | PyArrow, DataFrames.jl, arrow-rs, arrow (R) |
| Large ‚Äî GB, in-process | Arrow IPC over UNIX socket or shared memory | Libraries above + `mmap` |
| Streaming / real-time | stdin/stdout pipe with NDJSON or MessagePack | Language-native stream parsing |

### Recommended pipeline pattern (today)

```bash
# Python writes preprocessing result to Arrow IPC
polyscript py  preprocess.py  /data/raw.parquet  /tmp/ps_features.arrow

# Julia reads Arrow, runs ODE solver, writes result
polyscript jl  simulate.jl    /tmp/ps_features.arrow  /tmp/ps_result.arrow

# R reads Arrow, renders ggplot2 figures
polyscript r   plot.r         /tmp/ps_result.arrow    /tmp/figures/
```

```python
# preprocess.py ‚Äî write Arrow IPC
import sys, pyarrow as pa, pyarrow.parquet as pq, pyarrow.ipc as ipc

df = pq.read_table(sys.argv[1])
# ... transform ...
with ipc.new_file(sys.argv[2], df.schema) as w:
    w.write_table(df)
```

```julia
# simulate.jl ‚Äî read Arrow IPC
using Arrow, DataFrames
df = DataFrame(Arrow.Table(ARGS[1]))
# ... simulate ...
Arrow.write(ARGS[2], df)
```

### In-process zero-copy (Python + C++)

For Python (PyO3) and C++ (libloading), data stays inside the Rust process ‚Äî no disk I/O needed:

```python
# Python script can share numpy arrays with the host Rust process
# via PyO3's buffer protocol (future Phase 3 feature)
import numpy as np
import sys

data = np.load(sys.argv[1])       # mmap-backed array
result = model(data)               # in-process, no copy to disk
np.save(sys.argv[2], result)
```

### Planned IPC enhancements (Phase 2/3)

```
Phase 2: --ipc-format=arrow|parquet|json flag
         Arrow IPC file auto-written to /tmp/polyscript_ipc_<uuid>.arrow
         Path injected via POLYSCRIPT_IPC_PATH env var

Phase 3: Python (PyO3) / C++ (libloading) share Arrow RecordBatch
         raw pointer directly ‚Äî zero-copy, no disk I/O
```

---

## Project structure

```
polyscript/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs          CLI (clap derive) ¬∑ S shared args ¬∑ 16-arm dispatch     (79)
‚îÇ   ‚îî‚îÄ‚îÄ bridge/
‚îÇ       ‚îú‚îÄ‚îÄ mod.rs        sp() / cr() + sp_bridge! / cr_bridge! + 14 inline mods (63)
‚îÇ       ‚îú‚îÄ‚îÄ python.rs     PyO3 in-process FFI                                     (20)
‚îÇ       ‚îú‚îÄ‚îÄ julia.rs      super::sp() one-line wrapper (libjulia swap point)       (2)
‚îÇ       ‚îî‚îÄ‚îÄ cpp.rs        libloading dynamic library + unsafe extern "C" call     (23)
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ python/example.py       sys.argv demo
‚îÇ   ‚îú‚îÄ‚îÄ julia/example.jl        ARGS demo
‚îÇ   ‚îú‚îÄ‚îÄ cpp/example.cpp         extern "C" int run(argc, argv)
‚îÇ   ‚îú‚îÄ‚îÄ go/example.go           os.Args[1:]
‚îÇ   ‚îú‚îÄ‚îÄ js/example.js           process.argv.slice(2)
‚îÇ   ‚îú‚îÄ‚îÄ ts/example.ts           Deno.args
‚îÇ   ‚îú‚îÄ‚îÄ lua/example.lua         arg table
‚îÇ   ‚îú‚îÄ‚îÄ r/example.r             commandArgs(trailingOnly=TRUE)
‚îÇ   ‚îú‚îÄ‚îÄ mojo/example.mojo       argv()[1:]
‚îÇ   ‚îú‚îÄ‚îÄ zig/example.zig         std.process.args()
‚îÇ   ‚îú‚îÄ‚îÄ wasm/example.wat        WASI fd_write hello (compile with wat2wasm)
‚îÇ   ‚îú‚îÄ‚îÄ haskell/example.hs      System.Environment.getArgs
‚îÇ   ‚îú‚îÄ‚îÄ swift/example.swift     CommandLine.arguments.dropFirst()
‚îÇ   ‚îú‚îÄ‚îÄ kotlin/example.kts      args.toList()
‚îÇ   ‚îú‚îÄ‚îÄ nim/example.nim         commandLineParams()
‚îÇ   ‚îî‚îÄ‚îÄ fortran/example.f90     get_command_argument loop
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îî‚îÄ‚îÄ spec.md                 full design spec ‚Äî data IPC, cold-start, dep-env (gitignored)
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ LICENSE-MIT
‚îú‚îÄ‚îÄ LICENSE-APACHE
‚îî‚îÄ‚îÄ Cargo.toml
```

---

## Error handling

polyscript propagates errors through a single `anyhow::Result<()>` chain from `main`.

| Source | Behaviour | User-visible message |
|---|---|---|
| Script file not found | `fs::read_to_string` I/O error (Python only) | `No such file or directory (os error 2)` |
| Runtime not in `$PATH` | `std::process::Command` spawn error | `No such file or directory (os error 2)` |
| Non-zero exit from subprocess | `ensure!(s.success(), ...)` | `<cmd> exited with exit status: <N>` |
| Fortran compile failure | `ensure!(status.success(), ...)` | `gfortran: compilation failed` |
| libloading symbol not found | `lib.get(...)` error | libloading symbol error message |
| C++ function non-zero return | `ensure!(ret == 0, ...)` | `C++ function returned <N>` |
| PyO3 Python exception | PyO3 error type | Python traceback included |

All errors bubble up to `main` and are printed to stderr by `anyhow`. The process exits with code `1` on any error.

```bash
# Runtime missing
polyscript jl script.jl
# Error: No such file or directory (os error 2)

# Script exits non-zero
polyscript py failing.py
# Error: python exited with exit status: 1

# C++ wrong return value
polyscript cpp libex.dylib run
# Error: C++ function returned 42
```

---

## Building and testing

```bash
# Build (requires Python dev headers for PyO3)
cargo build --release

# Run all tests
cargo test

# Lint
cargo clippy --all-targets -- -D warnings

# Format check
cargo fmt --all -- --check

# Smoke-test all example scripts (requires all runtimes in $PATH)
polyscript py    scripts/python/example.py    smoke
polyscript jl    scripts/julia/example.jl     smoke
polyscript go    scripts/go/example.go        smoke
polyscript js    scripts/js/example.js        smoke
polyscript ts    scripts/ts/example.ts        smoke
polyscript lua   scripts/lua/example.lua      smoke
polyscript r     scripts/r/example.r          smoke
polyscript zig   scripts/zig/example.zig      smoke
polyscript hs    scripts/haskell/example.hs   smoke
polyscript swift scripts/swift/example.swift  smoke
polyscript kt    scripts/kotlin/example.kts   smoke
polyscript nim   scripts/nim/example.nim      smoke
polyscript fort  scripts/fortran/example.f90  smoke
```

---

## Known limitations

### Cold-start on subprocess languages

Julia (`jl`) incurs 1‚Äì4 s JIT startup per call ‚Äî avoid in tight loops.  
Kotlin (`kt`) incurs 500 ms‚Äì1 s JVM boot ‚Äî use GraalVM Native Image AOT for production.  
Mitigation planned: `libjulia-sys` native FFI for Julia; daemon mode for persistent runtimes.

### Concurrent `fort` subcommands

`cr_bridge!(fort, ...)` compiles to the fixed path `/tmp/polyscript_out`.  
Running two `fort` subcommands in parallel will overwrite each other's binary.  
Mitigation: use `/tmp/polyscript_out_<pid>` (planned).

### No structured IPC

Data passing is today limited to string CLI arguments and file paths.  
Arrow IPC / Parquet path-passing is the recommended workaround. See [Data IPC](#data-ipc--passing-data-between-languages).

### Wasm example requires pre-compilation

`scripts/wasm/example.wat` is WebAssembly Text Format source.  
It must be compiled before use: `wat2wasm scripts/wasm/example.wat -o example.wasm`

---

## Roadmap

### Data IPC
- [ ] `--ipc-format=arrow|parquet|json` flag
- [ ] Auto-write Arrow IPC to `/tmp/polyscript_ipc_<uuid>.arrow`, inject via `POLYSCRIPT_IPC_PATH`
- [ ] PyO3 / libloading zero-copy Arrow `RecordBatch` pointer sharing

### Cold-start mitigation
- [ ] Julia: `libjulia-sys` native FFI (in-process, zero startup)
- [ ] Kotlin: GraalVM Native Image mode
- [ ] Daemon mode: persistent runtime over Unix socket (`polyscript daemon start`)
- [ ] Concurrent `fort` safety: per-PID temp binary path

### Dependency management
- [ ] `devbox.json` ‚Äî all 14 runtimes pinned with [Devbox](https://www.jetify.com/devbox/)
- [ ] `Dockerfile` ‚Äî all-runtimes container image
- [ ] `.mise.toml` ‚Äî per-language version pinning

### Other
- [ ] `polyscript.toml` ‚Äî script registry with aliases (`polyscript run preprocess`)
- [ ] Parallel execution: `polyscript parallel py a.py -- jl b.jl`
- [ ] C++: `bindgen` auto-header binding generation
- [ ] WASM Component Model support (multi-language composition without file IPC)

---

## License

Licensed under either of

- **MIT License** ([LICENSE-MIT](LICENSE-MIT) or https://opensource.org/licenses/MIT)
- **Apache License, Version 2.0** ([LICENSE-APACHE](LICENSE-APACHE) or https://www.apache.org/licenses/LICENSE-2.0)

at your option.

### Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this project by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.


[![Rust](https://img.shields.io/badge/rust-2024_edition-orange?logo=rust)](https://www.rust-lang.org/)
[![License: MIT OR Apache-2.0](https://img.shields.io/badge/license-MIT%20OR%20Apache--2.0-blue)](#license)
[![Build](https://img.shields.io/badge/build-passing-brightgreen)](#getting-started)

---

## Table of Contents

- [Overview](#overview)
- [Supported Languages](#supported-languages)
- [Architecture](#architecture)
- [Getting Started](#getting-started)
  - [Prerequisites](#prerequisites)
  - [Build](#build)
  - [Usage](#usage)
- [Subcommands](#subcommands)
- [Example Scripts](#example-scripts)
- [Data IPC ‚Äî Passing Data Between Languages](#data-ipc--passing-data-between-languages)
- [Known Limitations](#known-limitations)
- [Project Structure](#project-structure)
- [Dependencies](#dependencies)
- [Roadmap](#roadmap)
- [License](#license)

---

## Overview

`polyscript` is a **Rust-native CLI orchestrator** that lets you invoke scripts written in any of 16 languages from a single unified command interface.

```
polyscript py   scripts/python/example.py   --  # ML / data processing (PyO3 in-process)
polyscript jl   scripts/julia/example.jl        # heavy numerical simulation
polyscript go   scripts/go/example.go           # concurrent cloud tooling
polyscript cpp  ./libexample.dylib run           # C++ shared library (libloading)
polyscript zig  scripts/zig/example.zig          # bare-metal / C replacement
# ... and 11 more
```

**Design philosophy**

| Principle | Detail |
|---|---|
| **Right tool for the job** | Each language is called only when it genuinely excels at the task |
| **Zero new files per language** | All 13 subprocess bridges are generated by two macros in one file |
| **Explicit fail-fast** | Missing runtime ‚Üí `command not found` immediately, no silent fallback |
| **Layered IPC** | CLI args ‚Üí file-path ‚Üí Arrow IPC, depending on data size |

---

## Supported Languages

| # | Language | Subcommand | Bridge method | Primary use case |
|---|---|---|---|---|
| 1 | ü¶Ä **Rust** | *(orchestrator)* | ‚Äî | CLI routing, error propagation |
| 2 | üêç **Python** | `py` | PyO3 in-process FFI | ML/AI, pandas, data pipelines |
| 3 | üî¨ **Julia** | `jl` | subprocess | Numerical simulation, ODE, SciML |
| 4 | ‚öôÔ∏è **C++** | `cpp` | libloading (dynamic load) | High-speed libs, legacy code, SIMD |
| 5 | üêπ **Go** | `go` | subprocess (`go run`) | Cloud APIs, DevOps tools, concurrent CLI |
| 6 | üåê **JavaScript** | `js` | subprocess (`node`) | I/O-bound scripts, JSON, web scraping |
| 7 | üî∑ **TypeScript** | `ts` | subprocess (`deno run`) | Type-safe I/O scripts, secure sandboxing |
| 8 | üåô **Lua** | `lua` | subprocess (`lua`) | Game scripting, embedded config, NGINX mods |
| 9 | üìä **R** | `r` | subprocess (`Rscript`) | Statistical analysis, research visualisation |
| 10 | üî• **Mojo** | `mojo` | subprocess (`mojo`) | Python-compatible AI kernels, GPU ops |
| 11 | ‚ö° **Zig** | `zig` | subprocess (`zig run`) | C replacement, cross-compilation |
| 12 | üî∑ **WebAssembly** | `wasm` | subprocess (`wasmtime run`) | Secure sandboxed plugins, edge compute |
| 13 | Œª **Haskell** | `hs` | subprocess (`runghc`) | Finance / DSL / type-safe backends |
| 14 | üçé **Swift** | `swift` | subprocess (`swift`) | Apple SDK, macOS-native processing |
| 15 | ‚òï **Kotlin** | `kt` | subprocess (`kotlinc -script`) | JVM ecosystem, Android, Gradle DSL |
| 16 | ü¶é **Nim** | `nim` | subprocess (`nim r`) | Python-syntax with C-speed, DSL generation |
| 17 | üî¨ **Fortran** | `fort` | gfortran compile + run | HPC, CFD, climate models, legacy science |

---

## Architecture

```
polyscript (Rust binary)
‚îÇ
‚îú‚îÄ‚îÄ bridge::python   ‚Üê PyO3 (in-process, zero startup cost)
‚îú‚îÄ‚îÄ bridge::cpp      ‚Üê libloading (dynamic library load)
‚îÇ
‚îî‚îÄ‚îÄ bridge::*        ‚Üê generated by sp_bridge! / cr_bridge! macros
     ‚îú‚îÄ‚îÄ sp(cmd, pre[], script, args[])   generic subprocess runner
     ‚îú‚îÄ‚îÄ cr(compiler, flags[], ...)       compile ‚Üí temp binary ‚Üí run
     ‚îÇ
     ‚îú‚îÄ‚îÄ sp_bridge!(julia,  "julia")
     ‚îú‚îÄ‚îÄ sp_bridge!(go,     "go",      "run")
     ‚îú‚îÄ‚îÄ sp_bridge!(js,     "node")
     ‚îú‚îÄ‚îÄ sp_bridge!(ts,     "deno",    "run")
     ‚îú‚îÄ‚îÄ sp_bridge!(lua,    "lua")
     ‚îú‚îÄ‚îÄ sp_bridge!(r,      "Rscript")
     ‚îú‚îÄ‚îÄ sp_bridge!(mojo,   "mojo")
     ‚îú‚îÄ‚îÄ sp_bridge!(zig,    "zig",     "run")
     ‚îú‚îÄ‚îÄ sp_bridge!(wasm,   "wasmtime","run")
     ‚îú‚îÄ‚îÄ sp_bridge!(hs,     "runghc")
     ‚îú‚îÄ‚îÄ sp_bridge!(swift,  "swift")
     ‚îú‚îÄ‚îÄ sp_bridge!(kt,     "kotlinc", "-script")
     ‚îú‚îÄ‚îÄ sp_bridge!(nim,    "nim",     "r")
     ‚îî‚îÄ‚îÄ cr_bridge!(fort,   "gfortran")
```

All 13 subprocess bridges are **declared in 15 lines** ‚Äî no separate `.rs` file per language.

---

## Getting Started

### Prerequisites

#### Required (always)
- [Rust](https://rustup.rs/) 1.80+ (edition 2024)
- Python 3.x + development headers (for PyO3)

#### Optional (install only the languages you need)

| Language | Install |
|---|---|
| Julia | https://julialang.org/downloads/ |
| Go | https://go.dev/dl/ |
| Node.js | https://nodejs.org/ |
| Deno | `curl -fsSL https://deno.land/install.sh \| sh` |
| Lua | `brew install lua` / `apt install lua5.4` |
| R | https://cran.r-project.org/ |
| Mojo | https://docs.modular.com/mojo/manual/get-started |
| Zig | https://ziglang.org/download/ |
| Wasmtime | `curl https://wasmtime.dev/install.sh -sSf \| bash` |
| GHC (Haskell) | https://www.haskell.org/ghcup/ |
| Swift | https://swift.org/install/ |
| Kotlin | `brew install kotlin` / [SDKMAN](https://sdkman.io/) |
| Nim | https://nim-lang.org/install.html |
| GFortran | `brew install gcc` / `apt install gfortran` |

> **Tip ‚Äî reproducible environment**: Use [Devbox](https://www.jetify.com/devbox/) or Docker to pin all runtimes at once (see [Roadmap](#roadmap)).

### Build

```bash
git clone https://github.com/fumishiki/polyscript
cd polyscript
cargo build --release
# binary: ./target/release/polyscript
```

### Usage

```bash
polyscript <SUBCOMMAND> <script|lib> [args...]

# Examples
polyscript py   scripts/python/example.py  arg1 arg2
polyscript jl   scripts/julia/example.jl
polyscript go   scripts/go/example.go      hello
polyscript js   scripts/js/example.js
polyscript ts   scripts/ts/example.ts
polyscript lua  scripts/lua/example.lua
polyscript r    scripts/r/example.r
polyscript mojo scripts/mojo/example.mojo
polyscript zig  scripts/zig/example.zig
polyscript wasm scripts/wasm/example.wasm
polyscript hs   scripts/haskell/example.hs
polyscript swift scripts/swift/example.swift
polyscript kt   scripts/kotlin/example.kts
polyscript nim  scripts/nim/example.nim
polyscript fort scripts/fortran/example.f90

# C++ (shared library)
cd scripts/cpp
g++ -shared -fPIC -o libexample.dylib example.cpp
polyscript cpp ./libexample.dylib run arg1
```

---

## Subcommands

```
polyscript --help
```

```
Polyglot script runner ‚Äî 16 Ë®ÄË™û„Çí FFI / subprocess „ÅßÂëº„Å≥Âá∫„Åô

Usage: polyscript <COMMAND>

Commands:
  py     Python  (PyO3 in-process FFI)
  jl     Julia   (subprocess)
  go     Go      (go run)
  js     JavaScript (node)
  ts     TypeScript (deno run)
  lua    Lua     (lua)
  r      R       (Rscript)
  mojo   Mojo    (mojo)
  zig    Zig     (zig run)
  wasm   WebAssembly (wasmtime run)
  hs     Haskell (runghc)
  swift  Swift   (swift)
  kt     Kotlin  (kotlinc -script)
  nim    Nim     (nim r)
  fort   Fortran (gfortran compile + run)
  cpp    C++ shared library (libloading)
  help   Print this message or the help of the given subcommand(s)
```

---

## Example Scripts

Each language has a working example under `scripts/<lang>/`:

| File | What it does |
|---|---|
| `scripts/python/example.py` | Prints args via `sys.argv` |
| `scripts/julia/example.jl` | Prints `ARGS` |
| `scripts/go/example.go` | Prints `os.Args[1:]` |
| `scripts/js/example.js` | Prints `process.argv.slice(2)` |
| `scripts/ts/example.ts` | Prints `Deno.args` |
| `scripts/lua/example.lua` | Prints `arg` table |
| `scripts/r/example.r` | Prints `commandArgs(trailingOnly=TRUE)` |
| `scripts/mojo/example.mojo` | Prints `argv()[1:]` |
| `scripts/zig/example.zig` | Iterates `std.process.args()` |
| `scripts/wasm/example.wat` | WASI hello world (compile with `wat2wasm`) |
| `scripts/haskell/example.hs` | Prints `getArgs` |
| `scripts/swift/example.swift` | Prints `CommandLine.arguments.dropFirst()` |
| `scripts/kotlin/example.kts` | Prints `args.toList()` |
| `scripts/nim/example.nim` | Prints `commandLineParams()` |
| `scripts/fortran/example.f90` | Iterates `get_command_argument` |
| `scripts/cpp/example.cpp` | `extern "C" int run(argc, argv)` |

---

## Data IPC ‚Äî Passing Data Between Languages

The current subcommand signature `<script> [args...]` passes **string arguments only**.  
For larger data, use the following layered strategy:

| Data size | Method | Notes |
|---|---|---|
| Small (flags, IDs) | CLI `[args...]` / env vars | Supported today |
| Medium (MB‚Äìhundreds of MB) | **Parquet / Arrow file path** as argument | Each language reads with native libs (PyArrow, DataFrames.jl, arrow-rs) |
| Large (GB, in-process) | **Apache Arrow IPC** (shared memory / UNIX socket) | Zero-copy. Python (PyO3) and C++ (libloading) can share raw memory pointers directly |
| Streaming | stdout/stdin pipe (NDJSON / MessagePack) | Lightweight real-time use |

**Recommended pattern for ML pipelines today:**

```bash
# 1. Python writes Arrow IPC to temp file
polyscript py  preprocess.py  /data/input.parquet /tmp/features.arrow

# 2. Julia reads the Arrow file for heavy simulation
polyscript jl  simulate.jl    /tmp/features.arrow /tmp/result.arrow

# 3. Python reads result for final aggregation
polyscript py  aggregate.py   /tmp/result.arrow
```

---

## Known Limitations

### 1. Cold-start latency (subprocess languages)

| Language | Startup overhead | Severity |
|---|---|---|
| Julia | ~seconds (JIT) | üî¥ High ‚Äî avoid tight loops |
| Kotlin | ~hundreds ms (JVM) | üü° Medium |
| Swift | ~hundreds ms | üü° Medium |
| Go / Deno / Node | ~tens ms | üü¢ Acceptable |
| Python (PyO3) | zero | ‚úÖ |
| C++ (libloading) | zero | ‚úÖ |

**Mitigations planned**: Julia ‚Üí `libjulia-sys` native FFI; Kotlin ‚Üí GraalVM Native Image; daemon mode for persistent runtimes.

### 2. Runtime dependencies

This tool requires each language's runtime to be in `$PATH`.  
A missing runtime causes an immediate, explicit error (`command not found`).  
Reproducible environment tooling (`devbox.json`, `Dockerfile`) is planned ‚Äî see [Roadmap](#roadmap).

### 3. No structured IPC yet

Data passing is currently limited to string CLI arguments.  
Arrow IPC / Parquet path-passing is the recommended workaround for large data today.

---

## Project Structure

```
polyscript/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs               # CLI (clap derive) ¬∑ S shared args type ¬∑ 16-arm dispatch
‚îÇ   ‚îî‚îÄ‚îÄ bridge/
‚îÇ       ‚îú‚îÄ‚îÄ mod.rs            # sp() / cr() helpers + sp_bridge! / cr_bridge! macros
‚îÇ       ‚îÇ                     #   ‚Üí inline modules: julia go js ts lua r mojo zig wasm
‚îÇ       ‚îÇ                     #                     hs swift kt nim fort
‚îÇ       ‚îú‚îÄ‚îÄ python.rs         # PyO3 in-process FFI
‚îÇ       ‚îú‚îÄ‚îÄ julia.rs          # thin super::sp() wrapper (swap point for libjulia)
‚îÇ       ‚îî‚îÄ‚îÄ cpp.rs            # libloading dynamic library loader
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ python/example.py
‚îÇ   ‚îú‚îÄ‚îÄ julia/example.jl
‚îÇ   ‚îú‚îÄ‚îÄ cpp/example.cpp
‚îÇ   ‚îú‚îÄ‚îÄ go/example.go
‚îÇ   ‚îú‚îÄ‚îÄ js/example.js
‚îÇ   ‚îú‚îÄ‚îÄ ts/example.ts
‚îÇ   ‚îú‚îÄ‚îÄ lua/example.lua
‚îÇ   ‚îú‚îÄ‚îÄ r/example.r
‚îÇ   ‚îú‚îÄ‚îÄ mojo/example.mojo
‚îÇ   ‚îú‚îÄ‚îÄ zig/example.zig
‚îÇ   ‚îú‚îÄ‚îÄ wasm/example.wat      # compile: wat2wasm example.wat -o example.wasm
‚îÇ   ‚îú‚îÄ‚îÄ haskell/example.hs
‚îÇ   ‚îú‚îÄ‚îÄ swift/example.swift
‚îÇ   ‚îú‚îÄ‚îÄ kotlin/example.kts
‚îÇ   ‚îú‚îÄ‚îÄ nim/example.nim
‚îÇ   ‚îî‚îÄ‚îÄ fortran/example.f90
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îî‚îÄ‚îÄ spec.md               # full design spec (gitignored ‚Äî local only)
‚îî‚îÄ‚îÄ Cargo.toml
```

---

## Dependencies

### Rust crates

| Crate | Version | Purpose |
|---|---|---|
| [`clap`](https://docs.rs/clap) | 4 | CLI parsing (derive feature) |
| [`pyo3`](https://pyo3.rs/) | 0.22 | Python in-process FFI |
| [`libloading`](https://docs.rs/libloading) | 0.8 | C++ shared library dynamic loading |
| [`anyhow`](https://docs.rs/anyhow) | 1 | Ergonomic error handling |

### C++ shared library convention

Functions exposed to `polyscript cpp` must follow this signature:

```cpp
extern "C" int run(int argc, const char** argv);
// returns 0 on success, non-zero on failure
```

---

## Roadmap

### Data IPC
- [ ] `--ipc-format=arrow|parquet|json` flag
- [ ] Auto-write Arrow IPC to `/tmp/polyscript_ipc_<uuid>.arrow`, pass path via `POLYSCRIPT_IPC_PATH` env var
- [ ] Zero-copy Arrow `RecordBatch` pointer sharing for Python (PyO3) and C++ (libloading)

### Cold-start mitigation
- [ ] Julia: migrate to `libjulia-sys` native FFI (in-process)
- [ ] Kotlin: GraalVM Native Image mode (AOT compiled binary)
- [ ] Daemon mode: persistent runtime over Unix socket (`--daemon` flag)

### Dependency management
- [ ] `devbox.json` ‚Äî pin all 14 runtimes with [Devbox](https://www.jetify.com/devbox/)
- [ ] `Dockerfile` ‚Äî all-runtimes container image
- [ ] `.mise.toml` ‚Äî per-language version pinning

### Other
- [ ] C++: `bindgen` auto-header binding generation
- [ ] `polyscript.toml` config file for script registry
- [ ] Parallel execution mode (run multiple languages concurrently)
- [ ] WASM Component Model support (multi-language composition)

---

## License

Licensed under either of

- **MIT License** ([LICENSE-MIT](LICENSE-MIT) or https://opensource.org/licenses/MIT)
- **Apache License, Version 2.0** ([LICENSE-APACHE](LICENSE-APACHE) or https://www.apache.org/licenses/LICENSE-2.0)

at your option.

### Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this project by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.
